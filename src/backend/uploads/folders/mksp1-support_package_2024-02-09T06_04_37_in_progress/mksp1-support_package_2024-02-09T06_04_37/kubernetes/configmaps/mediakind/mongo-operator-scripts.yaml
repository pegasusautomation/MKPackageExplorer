data:
  run.sh: "#!/bin/bash\n\n# Use this pattern to strip out the constructors that Mongo\
    \ adds for non-JSON types\nCONFIG_FILE='/etc/mongo-operator/config/mongo-operator-conf'\n\
    SECRETS_FILE='/etc/mongo-operator/secrets/mongo-operator-secrets'\nJSON_STRIPPER='s/\\\
    w+\\([^)]+\\)/null/g'\n\n# Globals\ndaemon=false\njob=false\nrunning=true\ndebug=false\n\
    # Set modified dates to 0 to force an initial update\nconfigHash=0\nsecretsHash=0\n\
    processName='Mongo Operator'\nhostname=$(uname -n)\n\n# Config\nloggingLevel=info\n\
    mongoUrl=''\ndesiredFeatureVersion=''\nusername=''\npassword=''\nretryInterval=10\n\
    sleepInterval=60\nfirstStatusOutput=true\n\n# Print the date in ISO8601 format\n\
    isodate() {\n    date --utc '+%FT%T.%3NZ'\n}\n\n# Log an info message to stderr\n\
    logInfo() {\n    echo {\\\"time\\\": \\\"$(isodate)\\\", \\\"host\\\": \\\"$hostname\\\
    \", \\\"pname\\\": \\\"$processName\\\", \\\"msg\\\": \\\"$1\\\", \\\"pri\\\"\
    : \\\"INFO\\\"} >&2\n}\n\n# Log an error message to stderr\nlogError() {\n   \
    \ echo {\\\"time\\\": \\\"$(isodate)\\\", \\\"host\\\": \\\"$hostname\\\", \\\"\
    pname\\\": \\\"$processName\\\", \\\"msg\\\": \\\"$1\\\", \\\"pri\\\": \\\"ERROR\\\
    \"} >&2\n}\n\n# Log an info message to stderr\nlogDebug() {\n    if ${debug};\
    \ then\n        echo {\\\"time\\\": \\\"$(isodate)\\\", \\\"host\\\": \\\"$hostname\\\
    \", \\\"pname\\\": \\\"$processName\\\", \\\"msg\\\": \\\"$1\\\", \\\"pri\\\"\
    : \\\"DEBUG\\\"} >&2\n    fi\n}\n\n# Create mongo shell authentication args and\
    \ write to stdout\ncreateAuthArgs() {\n    local username=$1\n    local password=$2\n\
    \n    local authArgs=\"\"\n    if [ ! -z \"${username}\" ]; then\n        authArgs=\"\
    --username ${username} --password ${password}\"\n    fi\n\n    echo ${authArgs}\n\
    }\n\n# Uses the json parsing of mongo shell to return what we want\nfake_jq()\
    \ {\n  local json=$1\n  local searchfor=$2\n  echo \"const data = ${json} ; data.${searchfor}\"\
    \ | mongo --quiet --nodb\n}\n\n# Run the specified admin command and write the\
    \ response to stdout\nrunAdminCommand() {\n    local host=$1\n    local command=$2\n\
    \    local username=$3\n    local password=$4\n\n    logDebug \"runAdminCommand\
    \ ${command} on ${host}\"\n\n    # Execute the mongo admin command\n    local\
    \ authArgs=$(createAuthArgs ${username} ${password})\n    local r\n    r=$(mongo\
    \ \"mongodb://${host}\" ${authArgs} --quiet --eval \"db.adminCommand(${command})\"\
    )\n    if [ $? -ne 0 ]; then\n        logError \"Mongo command ${command} failed.\"\
    \n        logError \"${r}\"\n        return 1\n    fi\n\n    # Remove non-strict\
    \ JSON syntax\n    local stripped=$(echo ${r} | sed -E ${JSON_STRIPPER})\n\n \
    \   # Admin commands all have an 'ok' field set to 0 or 1\n    local ok=$(fake_jq\
    \ \"${stripped}\" ok )\n    if [ \"${ok}\" == \"1\" ]; then\n        echo \"${stripped}\"\
    \ # Return value\n        return 0\n    else\n        return 1\n    fi\n}\n\n\
    # If the versions match across all hosts, the function will succeed and write\
    \ the version to stdout\ngetVersion() {\n    local mongoUrl=$1\n    local username=$2\n\
    \    local password=$3\n\n    # Grab the version for each mongo host\n    local\
    \ mongoHosts m v\n    local version=\"\"\n    IFS=',' read -ra mongoHosts <<<\
    \ \"${mongoUrl}\"\n    for m in \"${mongoHosts[@]}\"; do\n        local authArgs=$(createAuthArgs\
    \ ${username} ${password})\n        v=$(mongo \"mongodb://${m}\" ${authArgs} --quiet\
    \ --eval \"db.version()\")\n        if [ $? -ne 0 ]; then\n            logError\
    \ \"Failed get the version for member ${m}\"\n            return 1\n        elif\
    \ [ -z \"${v}\" ]; then\n            logError \"Version is empty for member ${m}\"\
    \n            return 1\n        elif [ ! -z \"${v}\" ] && [ -z \"${version}\"\
    \ ]; then\n            # We haven't seen a version yet, so store it\n        \
    \    version=${v}\n            logDebug \"Member ${m} version is ${v}\"\n    \
    \    elif [ \"${v}\" != \"${version}\" ]; then\n            logError \"Member\
    \ ${m} version ${v} is different from previously seen version ${version}\"\n \
    \           return 1\n        # else the version matched, so just continue\n \
    \       fi\n    done\n\n    # We succeeded if version is not empty\n    if [ !\
    \ -z \"${version}\" ]; then\n        echo \"${version}\" # Return value\n    \
    \    return 0\n    else\n        return 1\n    fi\n}\n\n# Get the master DB member\
    \ and write it to stdout\ngetMaster() {\n    local mongoUrl=$1\n    local username=$2\n\
    \    local password=$3\n\n    local mongoHosts m result master\n    IFS=',' read\
    \ -ra mongoHosts <<< \"${mongoUrl}\"\n    for m in \"${mongoHosts[@]}\"; do\n\
    \        result=$(runAdminCommand ${m} '{ isMaster: null }' ${username} ${password})\n\
    \        if [ $? -ne 0 ]; then\n            # Failed, try another mongo\n    \
    \        break\n        fi\n\n        # Each response contains a reference to\
    \ the primary, so we only need one response\n        master=$(fake_jq \"${result}\"\
    \ primary)\n        if [ ! -z \"${master}\" ]; then\n            echo \"${master}\"\
    \ # Return value\n            return 0\n        fi\n    done\n\n    return 1\n\
    }\n\n# Ensure that the main loop can exit\nstop() {\n    signal=$1\n    running=false\n\
    \    logInfo \"Exiting on ${signal}...\"\n}\n\n# Read in the config and secrets\
    \ if they've changed\nupdateConfig() {\n    local updated=false\n    local newConfigHash=$(sha1sum\
    \ ${CONFIG_FILE} | awk '{print $1}')\n    if [[ ${newConfigHash} != ${configHash}\
    \ ]]; then\n        source ${CONFIG_FILE}\n        desiredFeatureVersion=${featureCompatibilityVersion}\n\
    \        configHash=${newConfigHash}\n\n        # Set the logging level\n    \
    \    if [ \"${loggingLevel}\" == \"debug\" ]; then\n            debug=true\n \
    \       fi\n\n        updated=true\n    fi\n\n    local newSecretsHash=$(sha1sum\
    \ ${SECRETS_FILE} | awk '{print $1}')\n    if [[ ${newSecretsHash} != ${secretsHash}\
    \ ]]; then\n        source \"${SECRETS_FILE}\"\n        secretsHash=${newSecretsHash}\n\
    \        updated=true\n    fi\n\n    if ${updated}; then\n        # Create redacted\
    \ variables for the username and password\n        local redactedUsername=\"<blank>\"\
    \n        if [ ! -z \"${username}\" ]; then\n            redactedUsername=\"<supplied>\"\
    \n        fi\n        local redactedPassword=\"<blank>\"\n        if [ ! -z \"\
    ${password}\" ]; then\n            redactedPassword=\"<supplied>\"\n        fi\n\
    \n        # Checking for variables to have come from config.  Exit if missing.\n\
    \        if [ -z \"${mongoUrl}\" ] ; then\n          logError \"mongoUrl not set\"\
    \n          exit 5\n        fi\n        if [ -z \"${retryInterval}\" ] ; then\n\
    \          logError \"retryInterval not set\"\n          exit 5\n        fi\n\
    \        if [ -z \"${sleepInterval}\" ] ; then\n          logError \"sleepInterval\
    \ not set\"\n          exit 5\n        fi\n        if [ -z \"${featureCompatibilityVersion}\"\
    \ ] ; then\n          logError \"featureCompatibilityVersion not set\"\n     \
    \     exit 5\n        fi\n\n        # log the configuration in a single statement\n\
    \        local config=\"Config:\n        loggingLevel: ${loggingLevel}\n     \
    \   mongoUrl: ${mongoUrl}\n        featureCompatibilityVersion: ${desiredFeatureVersion}\n\
    \        retryInterval: ${retryInterval}\n        sleepInterval: ${sleepInterval}\n\
    \        username: ${redactedUsername}\n        password: ${redactedPassword}\"\
    \n        logInfo \"${config}\"\n    fi\n}\n\n# Check the current featureCompatibilityVersion\
    \ setting and update it if necessary\ncheckAndUpdateVersion() {\n    # Check all\
    \ the DB members are at the same version and get it\n    local version\n    version=$(getVersion\
    \ ${mongoUrl} ${username} ${password})\n    if [ $? -ne 0 ]; then\n        logError\
    \ \"Failed to confirm the same version number across all mongo members, retrying\
    \ in ${retryInterval} seconds\"\n        return 1\n    fi\n    logDebug \"Found\
    \ version: ${version}\"\n\n    # Find the master\n    local master\n    master=$(getMaster\
    \ ${mongoUrl} ${username} ${password})\n    if [ $? -ne 0 ]; then\n        logError\
    \ \"Failed to find the mongo master, retrying in ${retryInterval} seconds\"\n\
    \        return 1\n    fi\n    logDebug \"Found master: ${master}.\"\n\n    #\
    \ Get the current featureCompatibilityVersion\n    local result\n    result=$(runAdminCommand\
    \ ${master} '{ getParameter: null, featureCompatibilityVersion: null }' ${username}\
    \ ${password})\n    if [ $? -ne 0 ]; then\n        logError \"Failed to get the\
    \ featureCompatibilityVersion, retrying in ${retryInterval} seconds\"\n      \
    \  return 1\n    fi\n    local featureVersion=$(fake_jq \"${result}\" featureCompatibilityVersion.version)\n\
    \    logDebug \"Current featureCompatibilityVersion: ${featureVersion}\"\n\n \
    \   # Decide what the featureCompatibilityVersion should be\n    local newFeatureVersion=\"\
    ${desiredFeatureVersion}\"\n    if [ \"${newFeatureVersion}\" == \"latest\" ];\
    \ then\n        newFeatureVersion=$(echo ${version} | grep -Po '^\\d+\\.\\d+')\n\
    \    fi\n    logDebug \"Desired featureCompatibilityVersion: ${newFeatureVersion}\"\
    \n\n    # If the featureCompatibilityVersion is not what it should be, update\
    \ it\n    if [ \"${newFeatureVersion}\" != \"${featureVersion}\" ]; then\n   \
    \     logInfo \"Feature version is ${featureVersion} and should be ${newFeatureVersion},\
    \ attempting to update.\"\n        runAdminCommand ${master} \"{ setFeatureCompatibilityVersion:\
    \ '${newFeatureVersion}' }\" ${username} ${password} > /dev/null\n        if [\
    \ $? -ne 0 ]; then\n            logError \"Failed to set the featureCompatibilityVersion\
    \ on ${master}, retrying in ${retryInterval} seconds\"\n            return 1\n\
    \        fi\n\n        logInfo \"Feature version set to ${newFeatureVersion} on\
    \ master (${master}), sleeping for ${sleepInterval} seconds\"\n    else\n    \
    \    if $firstStatusOutput ; then\n          logInfo \"featureCompatibilityVersion\
    \ already set to ${newFeatureVersion}, sleeping for ${sleepInterval} seconds\"\
    \n          firstStatusOutput=false\n        else\n          logDebug \"featureCompatibilityVersion\
    \ already set to ${newFeatureVersion}, sleeping for ${sleepInterval} seconds\"\
    \n        fi\n    fi\n\n    return 0\n}\n\n# The loop that runs when the process\
    \ is daemonised\ndaemonLoop() {\n    # Ensure we exit quickly and cleanly\n  \
    \  trap 'stop SIGINT' SIGINT\n    trap 'stop SIGTERM' SIGTERM\n\n    # Run immediately\
    \ on first run\n    local sleepTime=0\n\n    # Run until we get interrupted\n\
    \    while ${running}; do\n        sleep ${sleepTime}\n        updateConfig\n\
    \        if checkAndUpdateVersion; then\n            # If this is being run as\
    \ a job, exit once the version is set correctly\n            if ${job}; then\n\
    \                return 0\n            else\n                # The version is\
    \ correct, so sleep for a longer time\n                sleepTime=${sleepInterval}\n\
    \            fi\n        else\n            # There was a problem in updating the\
    \ version, retry earlier\n            sleepTime=${retryInterval}\n        fi\n\
    \    done\n}\n\n# Print help to stdout\nprintHelp() {\n    echo \"$(cat <<-END\n\
    This script tries to set the MongoDB feature compatibility version. By default,\n\
    the script runs once. To run it to completion, use the --job parameter;\nto run\
    \ it forever, use the --daemon parameter.\n\nParameters: -\n\n--daemon, -d:  \
    \ Daemonise the script so it runs continuously.\n\n--job, -j:      Run the script\
    \ as a job so it retries until the feature compatibility\n                version\
    \ matches the expected version.\n\n--help, -h:     Print this help text.\n\n===================================================================\n\
    \nIn addition to command line parameters, the script accepts configuration from\
    \ files.\nThe script reads configuration from ${CONFIG_FILE},\nexample: -\n\n\
    \    {\n        \"loggingLevel\": \"info\",\n        \"mongoUrl\": \"mongodb-replicaset-0.mongodb-replicaset:27017,mongodb-replicaset-1.mongodb-replicaset:27017,mongodb-replicaset-2.mongodb-replicaset:27017\"\
    ,\n        \"featureCompatibilityVersion\": \"4.0\",\n        \"retryInterval\"\
    : ${retryInterval},\n        \"sleepInterval\": ${sleepInterval}\n    }\n\nloggingLevel\
    \ can be set to 'info' or 'debug', info and error messages are always written.\n\
    \nThe script reads secrets from ${SECRETS_FILE},\nexample: -\n\n    {\n      \
    \  \"username\": \"\",\n        \"password\": \"\"\n    }\n\nAn empty username\
    \ means don't use authentication.\nEND\n)\"\n}\n\n# Read the cli parameters\n\
    while [ $# -gt 0 ] ; do\n    case $1 in\n        --daemon|-d)    daemon=true ;\
    \ shift 1 ;;\n        --job|-j)       job=true ; shift 1 ;;\n        --help|-h)\
    \      printHelp; exit 0 ; shift 1 ;;\n        *)              echo \"Unknown\
    \ argument: $1\"; exit 1 ;;\n    esac\ndone\n\n# Only one running mode is allowed\n\
    if ${daemon} && ${job}; then\n    logError \"Cannot use daemon and job parameters\
    \ at the same time.\"\n    exit 1\nfi\n\n# Determine the running mode and execute\
    \ accordingly\nif ${daemon} || ${job}; then\n    # Run the daemon loop (also run\
    \ it for job mode)\n    daemonLoop\nelse\n    # Run once\n    checkAndUpdateVersion\n\
    \    if [ $? -ne 0 ]; then\n        exit 1\n    fi\nfi\n"
metadata:
  annotations:
    meta.helm.sh/release-name: mkc
    meta.helm.sh/release-namespace: mediakind
  creationTimestamp: '2023-12-14T10:09:17Z'
  labels:
    app.kubernetes.io/component: mongo-operator
    app.kubernetes.io/instance: mkc
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: mongo-operator
    app.kubernetes.io/part-of: mkc
    app.kubernetes.io/version: 1.19.0
    helm.sh/chart: mongo-operator-1.19.0
  managedFields:
  - apiVersion: v1
    fieldsType: FieldsV1
    fieldsV1:
      f:data:
        .: {}
        f:run.sh: {}
      f:metadata:
        f:annotations:
          .: {}
          f:meta.helm.sh/release-name: {}
          f:meta.helm.sh/release-namespace: {}
        f:labels:
          .: {}
          f:app.kubernetes.io/component: {}
          f:app.kubernetes.io/instance: {}
          f:app.kubernetes.io/managed-by: {}
          f:app.kubernetes.io/name: {}
          f:app.kubernetes.io/part-of: {}
          f:app.kubernetes.io/version: {}
          f:helm.sh/chart: {}
    manager: helm
    operation: Update
    time: '2023-12-14T10:09:17Z'
  name: mongo-operator-scripts
  namespace: mediakind
  resourceVersion: '18798'
  uid: 43683528-6d98-4cdc-ab90-950da7fdcfd2
